Задача очень похожа на ту, которую мы делали в качестве контрольной про коня. Я храню матрицу 101*101, в которой указано число переливаний, чтобы достигнуть этого состояния, то есть в ячейке [i][j] хранится число переливаний, необходимых, чтобы в пробирке 1 было i литров, а в пробирке 2 - j литров. Изначально там везде -1, и с помощью функции notVisited мы проверяем, что эта ячейка нами еще не посещалась, то есть там лежит -1. Это необходимо для того, чтобы мы много раз не попадали в одно и то же состояние. Еще есть функция inBounds для проверки, не получилось ли у нас при переливании отрицательное число литров или не стало ли их больше сотни.

Затем все просто:
1) Не знаю, считается ли это за костыль, но мы сразу проверяем: вдруг у нас уже необходимое число литров в третьей пробирке, и если это так - пишем в качестве ответа 0 и больше ничего не делаем
2) У нас есть очередь, с помощью которой мы будем делать наши переливания. В матрицу по элемент [нач.сост.пробирки1][нач.сост.пробирки2] закидываем 0 и в очередь закидываем наше начальное состояние. 
3) Запускаем цикл: пока очередь не пуста
4) Вытаскиваем текущее состояние из очереди и удаляем его из нее. Делаем проверку: вдруг у нас все уже хорошо и можно ничего не делать, если так - прерываем цикл.
5) Пробегаемся по вектору с нашими рисочками и перебираем все возможные варианты (см. комментарии в коде). Создаём пару с новой позицией для каждого варианта, проверяем, не вылетели ли мы за пределы и не посещали ли ее, и если все хорошо, то добавляем новую позицию в очередь, а в матрице в ячейку [новое число литров в пробирке 1][новое число литров в пробирке 2] кладём инкрементированное значение в ячейке матрицы с литражом на текущей позиции. 
Вуаля. 